# 一、线程安全分类

Java语言中各种操作共享的数据按线程安全级别可分为5类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。

不可变的对象一定是线程安全的，最典型的例子就是String。通过final关键字修饰，被正确地构建出来，没有发生this引用逃逸的情况，其外部的可见状态永远也不会改变。

绝对线程安全的定义是很严格的，这里不做过多介绍，只要知道，Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全，像Vector、HashTable等等这些，它们是相对线程安全的。虽然在这些类的内部，都用了synchronized对方法进行修饰来保证线程安全，但是很多时候，在使用这些类的时候，我们仍需要额外的同步措施。以Vector说明一下，它的get和remove方法是用synchronized修饰的，也就是：

```java
synchronized public T get(int i) {
    // 方法体
}

synchronized public T remove(int i) {
    // 方法体
}
```

所以在执行玩方法后就释放锁了。当有两个线程，一个执行循环get()操作，一个执行循环remove()操作：

```java
Thread1:
for (int i = 0; i < vector.size(); i++) {
    vector.remove(i);
}
Thread2:
for (int i = 0; i < vector.size(); i++) {
    vector.get(i);
}
```

因此，在多线程环境下，就有可能会发生，remove(0)先获得锁，get(0)后获得锁，remove(0)执行完释放锁，get(0)持有锁，但获取不到对象而报错。可以改为如下代码避免报错：

```java
Thread1:
synchronized (vector) {
	for (int i = 0; i < vector.size(); i++) {
        vector.remove(i);
    }
}
Thread2:
synchronized (vector) {
	for (int i = 0; i < vector.size(); i++) {
        vector.get(i);
    }
}
```

改为上面的代码，加锁在循环删除这一过程，元素没有删除光不会释放锁，以及加锁在循环get这一过程，元素没有完全遍历完不会释放锁，就不会出现第一种的报错问题了。

synchronized修饰的代码块，如果有指定参数时，那就是对这个参数对象加锁，如果没有，就看修饰的是静态方法还是非静态方法，静态方法加锁对象是这个类的class对象，非静态方法，加锁对象是这个实例对象。

synchronized互斥锁，是借助于monitorenter和monitorexit这两个字节码指令，并且具有线程重入特性，当进行monitorenter指令，持有锁后会把锁的计数器加1，而当当前线程已经拥有了那个对象的锁时，锁的计数器会继续加1。而当执行monitorexit指令时，锁的计数器会减1，直到锁的计数器为0释放锁。

synchronized加锁，需要操作系统层面来阻塞或者唤醒，因此，需要在用户态和核心态之间进行转换，这也是为什么synchronized是java语言的一个重量级锁。同时，自旋锁改善性能就在于，在通知操作系统阻塞线程之前加入了一段自旋等待过程，避免频繁地切入到核心态之中。

ReentrantLock和synchronized很相似，同样具有线程重入特性，代码写法上的不同是，一个是API层面的互斥锁（lock()和unlock()方法配合try/finally语句块来完成），另一个是原生语法层面的互斥锁。另外，ReentrantLock与synchronized相比，还增加了一些高级功能：等待可中断、可实现公平锁，以及锁可以绑定多个条件。

我用一段简单的伪代码来表示等待可中断：

```java
if (outOfTime) {
	doAnother();
}
else {
	doThis();
}
```

**公平锁：**指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。

synchronized是非公平锁，也就是说，多个线程等待同一个锁时，都有机会获得锁。ReentrantLock默认也是非公平锁，但可以通过带布尔值的构造函数要求使用公平锁。

**悲观锁：**总是认为只要不去做正确的同步措施，那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。

**乐观锁：**基于冲突检测的乐观并发策略，先进行操作，如果没有其他线程争用共享数据，那操作就成功了，如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施。这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步。

**CAS：**我尝试理解一下CAS，首先内存里的值V是共享的。假设现在有两个线程，线程1拿到V的值，记为V1，就赋给了A1，它要设置的新值为B1，另一个线程2，拿到V的值，因为线程1还没写入，依然是V1，就赋给了A2，它要设置的新值为B2，这时它去比较A2与当前内存的值V，因为线程1还没写入，所以还是V1，因为A2=V1，写入成功，变为V=B2，这时线程1开始要写入了，它比较A1与V，发现不相等了，那就再重新获取。