# 一、进程管理

## 进程与线程

1、进程是一段程序在某个数据集上的一次执行过程，进程是系统资源分配的基本单位，由程序段、数据段和进程控制块（PCB）组成；

2、线程可以看作是更轻量级的进程，线程是系统调度的最小单位，本身不拥有资源，仅拥有一些运行必不可少的资源；

3、进程和线程的区别：

* 线程是依托于进程而存在的，一个进程可以拥有多个线程，但一个线程只能所属于一个进程；
* 拥有资源：线程本身不占有资源，同个进程上的多个线程共享该进程的所有资源；
* 调度：同一进程上的线程切换不会引起进程切换，不同进程上的线程切换时才会引起进程切换；
* 系统开销：创建或撤销进程时，系统都要为之分配或回收资源，如内存、IO设备等，所付出的开销远大于创建或撤销线程时的开销。同样，在进行进程切换时，系统需要保存进程的CPU环境以及为新进程设置CPU环境，而线程的切换只需要保存和设置少量的寄存器内容，开销很小。

## 线程同步的方式

* 互斥量：采用互斥对象机制，只有拥有互斥对象的线程才能访问资源。由于互斥对象只有一个，因此可以保证公共资源不会被多个线程所访问。Java中的synchronized关键字和各种Lock锁就都是这种机制。
* 信号量：它允许同一时刻多个线程访问同一个资源，但是需要控制同一时刻访问此资源的最大线程数量。
* 事件（信号）：通过通知的操作来保持多线程的同步，还可以方便的实现多线程的优先级操作。Java中的wait/notify。

## 保持进程同步的方式

相关的几个概念：

* 临界区：访问临界资源的那一段代码称为临界区。为了互斥访问临界资源，每个进程在进入临界区之前需要进行检查。
* 互斥与同步：同步：多个进程之间因为合作而产生的直接制约关系，使得进程有一定的先后执行关系；互斥：多个进程在同一时刻只有一个能够进入临界区。

* 信号量机制：信号量是一个整型，通过信号量控制同一时刻访问同一资源的数量。
* 管程：由于信号量机制需要客户端编写相应的资源访问代码，不利于开发，管程将相应的控制代码独立出来，不仅不易出错，还使得客户端调用更加方便。

进程同步的主要方式有：原子操作、信号量机制、管程等。

## 进程的通信方式

### 1、共享存储块

允许多个进程访问同一块内存，由于数据不用在多个进程间复制，因此是最快的一种进程通信方式。

需要使用信号量机制来控制多个进程对共享内存的访问。

多个进程可以将一个文件映射到他们的地址空间从而实现共享内存。

## 2、管道

管道是通过pipe()函数创建的，管道是指用于连接读进程和写进程间的一个文件，称为pipe文件，是一个固定大小的缓冲区，当管道满了，写进程往里面写数据时会阻塞，直到读进程往文件读取出数据；同样，当管道为空时，读进程往里面读数据时将会阻塞，直到写进程往文件写入数据。

使用限制：

* 只支持半双工通信；
* 只能用于父子进程/兄弟进程。

### 3、命名管道

类似与管道，但不同的是，可以在非父子进程/兄弟进程间使用。

### 4、消息队列

进程间的数据交换以格式化的消息为单位。直接消息传递方式，发送进程将消息发送到接收进程的消息缓冲队列中，接收进程再到该内存中去取数据。简介消息传递方式，系统提供一个中间实体，发送进程将消息发送到该中间实体，接收进程再到该实体中去取数据。

### 5、套接字

可用于不同机器间的进程通信。

## 进程的状态及状态间的转换

进程的状态：创建、就绪、运行、阻塞、死亡。

主要三种状态转换：

* 就绪态->运行态：进程在获取到CPU分配的时间片后，将从就绪态进入到运行态；
* 运行态->就绪态：当运行进程时间片使用完或者被更高优先级的进程抢占时间片时，将从运行态转为就绪态，等待CPU的下一次调度；
* 运行态->阻塞态：运行进程等待某一事件而暂停运行，如等待某一资源可用，将从运行态转为阻塞态；
* 阻塞态->就绪态：当阻塞进程请求的资源得到满足时，就将从阻塞态转为就绪态。

## 进程调度策略/算法

主要有一下几种：

1、先来先服务(FCFS)：非抢占式的调度算法，按照请求的顺序进行调度。有利于长作业，但不利于短作业。

2、短作业优先(SJF)：非抢占式调度算法，按照估计运行时间最短的顺序进行调度。长作业可能会饿死，一直处于等待短作业执行完毕的状态。

3、时间片轮换：所有就绪进程按照FCFS的顺序进入一个队列，系统设置时间片大小，每次从队列中取出一个就绪进程执行，当时间片用完后，如果该进程还没完成，就将其插入队列的末尾，等待新一轮分配时间片调度执行。时间片轮转算法的效率与时间片的大小有很大关系。

4、多级反馈队列：多级反馈队列可以看做是时间片轮转算法和优先级算法的结合，通过设置多个队列，最上面的队列优先级最高，分配的时间片最短，只有当上面的队列为空，才可以执行当前的队列上的进程。

5、优先级算法：为每个进程分配一个优先级，按优先级进行调度。为防止低优先级的进程长时间得不到调度，可以根据等待时间调高进程的优先级。

## 孤儿进程、僵尸进程、守护进程

### 1、孤儿进程

如果父进程退出，子进程没退出，子进程将托孤给Init进程，也就是子进程的父进程是init进程。

### 2、僵尸进程

在Linux的进程状态中，有一种进程状态是僵死状态，当进程终止后，进入僵死状态，等待告知父进程自己终止后，才能完全消失。如果一个进程终止了，但是其父进程还未获取其状态，那么这个进程就称为僵尸进程。僵尸进程还会消耗一定的系统资源，并且还保留了一些概要信息供父进程查询，一旦父进程获取到想要的信息，僵尸进程就会结束。

### 3、守护进程

守护进程就是在后台运行，不与任何终端关联的进程。

# 二、死锁

## 什么是死锁

死锁是指多个进程因为互相竞争关系而造成的一种僵局（互相等待），若无外力作用，这些进程都无法向前推进。

## 必要条件

* 互斥：每个资源要么分配给一个进程，要么就是可用的。
* 等待与占有：已经得到某个资源的进程可以再请求新的资源。
* 不可剥夺：已经分配给一个进程的资源不能被强制性地占有，它只能被占有它的进程显式地释放。
* 环路等待：有两个或两个以上的进程组成一条环路，该环路的进程都在等待下一个进程所占有的资源。

## 处理方法

主要有四种方法：

* 鸵鸟策略
* 死锁预防
* 死锁避免
* 死锁检测与死锁恢复

### 1、鸵鸟策略

假装没发生问题，不采取任何策略。

### 2、死锁预防

* 破坏互斥条件
* 破坏占有与等待条件：一种实现方式是进程中开始执行前请求所需要的全部资源。
* 破坏不可剥夺条件
* 破坏环路等待条件：给资源统一编号，进程只能按照编号顺序来请求资源。

### 3、死锁避免

在程序运行时避免发生死锁，银行家算法。

### 4、死锁检测与死锁恢复

死锁检测：

* 资源分配图

死锁恢复：

* 资源剥夺法
* 撤销进程法
* 进程回退法

# 三、内存管理

## 操作系统中的内存管理主要是做什么

操作系统的内存管理主要负责内存的分配与回收，另外还有地址转换，也就是将逻辑地址转换为相应的物理地址等功能。

## 操作系统的内存管理机制？内存管理的方式

简单分为连续分配管理方式和非连续分配管理方式这两种。连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如块式管理。非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如页式管理、段式管理及段页式管理。

### 1、块式管理

块式管理是一种较老的内存管理方式。将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分会被浪费掉。这些在每块内存中未被利用的空间，称之为碎片。

### 2、页式管理

把内存划分成固定大小的一页，页较小，相比于块式管理，划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。

### 3、段式管理

段式管理方式按照用户进程中的自然段划分逻辑空间，把内存分成一段段的，一个段构成一个独立的地址空间。每个段的长度可以不同，段是有实际意义的，每个段定义了一组逻辑信息，段式管理通过段表对应逻辑地址和物理地址。

### 4、段页式管理

段页式管理将程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。结合了页式管理和段式管理的优点，既拥有分段系统的共享与保护，又拥有分页系统的虚拟内存功能。

## 分段与分页的共同点

* 页和段都是离散存储的，所以两者都是离散分配内存的方式。但是，每个页和段中的内存都是连续的。

## 分段与分页的比较

* 对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段；
* 地址空间的维度：分页是一维空间，分段是二维空间；
* 大小是否可以改变：页的大小不可变，段的大小可以动态改变；
* 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。

## 逻辑地址和物理地址

编程一般只可能与逻辑地址打交道，如指针中存放的数值可以理解为内存中的一个地址，这个地址就是逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中的地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。

## 快表和多级页表

分页内存管理中，很重要的两点是：

* 虚拟地址到物理地址的转换要快；
* 解决虚拟地址空间大，页表也会很大的问题。

### 1、快表

为了解决虚拟地址到物理地址的转换速度，操作系统在页表方案基础之上引入了块表来加速虚拟地址到物理地址的转换。可以把快表理解为一种特殊的高速缓存存储器，其中的内容是页表的一部分或者全部内容。作为页表的Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据时CPU要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。

使用快表之后的地址转换流程是这样的：

1、根据虚拟地址中的页号查快表；

2、如果该页在快表中，直接从快表中读取相应的物理地址；

3、如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；

4、当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。

### 2、多级页表

引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。多级页表属于时间换空间的典型场景。

## 局部性原理

* 时间上的局部性：最近被访问的页在不久的将来还会被访问，产生时间局部性的典型原因，是由于在程序中存在着大量的循环操作；
* 空间上的局部性：内存中被访问的页周围的页也很可能被访问，这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式聚簇存储的。

## 虚拟内存

又叫做虚拟存储器。通过虚拟内存，可以让程序可以拥有超过系统物理内存大小的可用内存空间。虚拟内存为每个进程提供了一个一致的、私有的地址空间，它让每个进程产生了一种自己在独享内存的错觉（每个进程拥有一片连续完整的内存空间）。这样会更加有效地管理内存并减少出错。虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并且把内存扩展到硬盘空间。

虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。

为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不存在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。

## 虚拟内存的技术实现

虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。虚拟内存的实现有以下三种方式：

1、请求分页存储管理：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。

2、请求分段存储管理：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。

3、请求段页式存储管理。

请求分页与分页存储管理，两者有何不同呢？

请求分页存储管理建立在分页管理之上。他们的根本区别在于是否将程序所需的全部地址空间都装入内存，这也是请求分页存储管理科员提供虚拟内存的原因。

不管是上面哪种实现方式，我们一般都需要：

1、一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；

2、缺页中断：如果需执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段调入到内存，然后继续执行程序；

3、虚拟地址空间：逻辑地址到物理地址的变换。

## 页面置换算法

在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。

页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已存在的缓存，这样才有空间存放新的缓存数据。

页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。

### 1、最佳页面置换算法（OPT)

所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。

是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。

### 2、最近最久未使用算法（LRU)

虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU将最近最久未使用的页面换出。

一般问这种算法都会经常问你怎么实现，就是链表加Map。

### 3、最近未使用（NRU）

### 4、先进先出（FIFO）

选择换出的页面是最先进入的页面。

该算法会将那些经常被访问的页面换出，导致缺页率升高。

### 5、时钟（Clock）

时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。

## 内存颠簸

内存颠簸本质上是指频繁的页调度行为，具体就是进程频繁发生缺页中断，这时必须置换某一页。然而，其他所有的也都在使用，它置换一个页，但又立刻再次需要这个页。因此，会不断产生缺页中断，导致整个系统的效率急剧下降，这种现象称为颠簸（抖动）。

### 解决策略

如果是因为页面替换策略失误，可以修改替换算法来解决这个问题；

如果是因为运行的程序太多，造成程序无法同时将所有频繁访问的页面调入内存，则要降低多道程序的数量；

另外两个办法：终止该进程或增加物理内存容量。

## 缓冲区溢出

缓冲区溢出是指当计算机向缓冲区填充数据时超过了缓冲区本身的容量，溢出的数据覆盖在合法数据上。造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入参数。

危害有以下两点：

* 程序崩溃，导致拒绝服务；
* 跳转并且执行一段恶意代码。

## 为什么页表是一维的，而段表是二维的

