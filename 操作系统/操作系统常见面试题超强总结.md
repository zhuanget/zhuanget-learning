# 一、进程管理

## 进程与线程

1、进程是一段程序在某个数据集上的一次执行过程，进程是系统资源分配的基本单位，由程序段、数据段和进程控制块（PCB）组成；

2、线程可以看作是更轻量级的进程，线程是系统调度的最小单位，本身不拥有资源，仅拥有一些运行必不可少的资源；

3、进程和线程的区别：

* 线程是依托于进程而存在的，一个进程可以拥有多个线程，但一个线程只能所属于一个进程；
* 拥有资源：线程本身不占有资源，同个进程上的多个线程共享该进程的所有资源；
* 调度：同一进程上的线程切换不会引起进程切换，不同进程上的线程切换时才会引起进程切换；
* 系统开销：创建或撤销进程时，系统都要为之分配或回收资源，如内存、IO设备等，所付出的开销远大于创建或撤销线程时的开销。同样，在进行进程切换时，系统需要保存进程的CPU环境以及为新进程设置CPU环境，而线程的切换只需要保存和设置少量的寄存器内容，开销很小。

## 线程同步的方式

* 互斥量：采用互斥对象机制，只有拥有互斥对象的线程才能访问资源。由于互斥对象只有一个，因此可以保证公共资源不会被多个线程所访问。Java中的synchronized关键字和各种Lock锁就都是这种机制。
* 信号量：它允许同一时刻多个线程访问同一个资源，但是需要控制同一时刻访问此资源的最大线程数量。
* 事件（信号）：通过通知的操作来保持多线程的同步，还可以方便的实现多线程的优先级操作。Java中的wait/notify。

## 保持进程同步的方式

相关的几个概念：

* 临界区：访问临界资源的那一段代码称为临界区。为了互斥访问临界资源，每个进程在进入临界区之前需要进行检查。
* 互斥与同步：同步：多个进程之间因为合作而产生的直接制约关系，使得进程有一定的先后执行关系；互斥：多个进程在同一时刻只有一个能够进入临界区。

* 信号量机制：信号量是一个整型，通过信号量控制同一时刻访问同一资源的数量。
* 管程：由于信号量机制需要客户端编写相应的资源访问代码，不利于开发，管程将相应的控制代码独立出来，不仅不易出错，还使得客户端调用更加方便。

进程同步的主要方式有：原子操作、信号量机制、管程等。

## 进程的通信方式

### 1、共享存储块

允许多个进程访问同一块内存，由于数据不用在多个进程间复制，因此是最快的一种进程通信方式。

需要使用信号量机制来控制多个进程对共享内存的访问。

多个进程可以将一个文件映射到他们的地址空间从而实现共享内存。

## 2、管道

管道是通过pipe()函数创建的，管道是指用于连接读进程和写进程间的一个文件，称为pipe文件，是一个固定大小的缓冲区，当管道满了，写进程往里面写数据时会阻塞，直到读进程往文件读取出数据；同样，当管道为空时，读进程往里面读数据时将会阻塞，直到写进程往文件写入数据。

使用限制：

* 只支持半双工通信；
* 只能用于父子进程/兄弟进程。

### 3、命名管道

类似与管道，但不同的是，可以在非父子进程/兄弟进程间使用。

### 4、消息队列

进程间的数据交换以格式化的消息为单位。直接消息传递方式，发送进程将消息发送到接收进程的消息缓冲队列中，接收进程再到该内存中去取数据。简介消息传递方式，系统提供一个中间实体，发送进程将消息发送到该中间实体，接收进程再到该实体中去取数据。

### 5、套接字

可用于不同机器间的进程通信。

## 进程的状态及状态间的转换

进程的状态：创建、就绪、运行、阻塞、死亡。

主要三种状态转换：

* 就绪态->运行态：进程在获取到CPU分配的时间片后，将从就绪态进入到运行态；
* 运行态->就绪态：当运行进程时间片使用完或者被更高优先级的进程抢占时间片时，将从运行态转为就绪态，等待CPU的下一次调度；
* 运行态->阻塞态：运行进程等待某一事件而暂停运行，如等待某一资源可用，将从运行态转为阻塞态；
* 阻塞态->就绪态：当阻塞进程请求的资源得到满足时，就将从阻塞态转为就绪态。

## 进程调度策略/算法

主要有一下几种：

1、先来先服务(FCFS)：非抢占式的调度算法，按照请求的顺序进行调度。有利于长作业，但不利于短作业。

2、短作业优先(SJF)：非抢占式调度算法，按照估计运行时间最短的顺序进行调度。长作业可能会饿死，一直处于等待短作业执行完毕的状态。

3、时间片轮换：所有就绪进程按照FCFS的顺序进入一个队列，系统设置时间片大小，每次从队列中取出一个就绪进程执行，当时间片用完后，如果该进程还没完成，就将其插入队列的末尾，等待新一轮分配时间片调度执行。时间片轮转算法的效率与时间片的大小有很大关系。

4、多级反馈队列：多级反馈队列可以看做是时间片轮转算法和优先级算法的结合，通过设置多个队列，最上面的队列优先级最高，分配的时间片最短，只有当上面的队列为空，才可以执行当前的队列上的进程。

5、优先级算法：为每个进程分配一个优先级，按优先级进行调度。为防止低优先级的进程长时间得不到调度，可以根据等待时间调高进程的优先级。

## 孤儿进程、僵尸进程、守护进程

### 1、孤儿进程

如果父进程退出，子进程没退出，子进程将托孤给Init进程，也就是子进程的父进程是init进程。

### 2、僵尸进程

在Linux的进程状态中，有一种进程状态是僵死状态，当进程终止后，进入僵死状态，等待告知父进程自己终止后，才能完全消失。如果一个进程终止了，但是其父进程还未获取其状态，那么这个进程就称为僵尸进程。僵尸进程还会消耗一定的系统资源，并且还保留了一些概要信息供父进程查询，一旦父进程获取到想要的信息，僵尸进程就会结束。

### 3、守护进程

守护进程就是在后台运行，不与任何终端关联的进程。

# 二、死锁

## 什么是死锁

死锁是指多个进程因为互相竞争关系而造成的一种僵局（互相等待），若无外力作用，这些进程都无法向前推进。

## 必要条件

* 互斥：每个资源要么分配给一个进程，要么就是可用的。
* 等待与占有：已经得到某个资源的进程可以再请求新的资源。
* 不可剥夺：已经分配给一个进程的资源不能被强制性地占有，它只能被占有它的进程显式地释放。
* 环路等待：有两个或两个以上的进程组成一条环路，该环路的进程都在等待下一个进程所占有的资源。

## 处理方法

主要有四种方法：

* 鸵鸟策略
* 死锁预防
* 死锁避免
* 死锁检测与死锁恢复

### 1、鸵鸟策略

假装没发生问题，不采取任何策略。

### 2、死锁预防

* 破坏互斥条件
* 破坏占有与等待条件：一种实现方式是进程中开始执行前请求所需要的全部资源。
* 破坏不可剥夺条件
* 破坏环路等待条件：给资源统一编号，进程只能按照编号顺序来请求资源。

### 3、死锁避免

在程序运行时避免发生死锁，银行家算法。

### 4、死锁检测与死锁恢复

死锁检测：

* 资源分配图

死锁恢复：

* 资源剥夺法
* 撤销进程法
* 进程回退法

# 三、内存管理

