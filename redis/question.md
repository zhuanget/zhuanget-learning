面经：

https://www.shuzhiduo.com/A/D854QQeVdE/

https://www.nowcoder.com/discuss/361709?type=2&order=3&pos=30&page=1&channel=-2&source_id=discuss_tag

http://www.mianshigee.com/article/46241qcd

http://www.mianshigee.com/article/47183jld



## 1、Redis

#### 1.1、redis为什么快？

首先要说明的是，redis的单线程的意思是用单线程处理客户端的请求。

redis快的原因，主要有4点：

* 基于内存实现，存储和读取快；
* 使用IO多路复用技术处理Socket请求；
* 单线程处理客户端请求，可以避免多线程间线程切换和锁资源争用的开销；
* 使用了很多优化的数据结构，提高性能。

#### 1.2、你平时用redis做什么呢？

* 用的最多的地方是做缓存，缓存一些热点数据，加快查询；
* 用作分布式锁，避免多实例间的同步问题；
* 用了三个set，存了最近三天的小图id，对大数据平台推送过来的数据做去重判断，避免重复计算。有缺陷，在于如果redis挂掉，会有一些重复数据。机制，全量更新，重新消费。

#### 1.3、redis持久化机制？

有两种，AOF和RDB，AOF是把redis每次修改数据的操作都追加到文件中，记录下来，当挂掉时，重新执行这些命令，恢复数据。而RDB是一种内存快照的形式，每隔一段时间获取一次快照数据，基于快照文件恢复数据。两种方式各有优劣，AOF恢复速度慢，RDB如果间隔时间设置太长，或者redis写入频繁时，可能会丢失较多的数据。AOF有三个选项可供设置更新频率：always、everySec、no。

#### 1.4、redis如何实现分布式锁？

* 针对单机情况，使用SETNX命令，该命令是原子性操作，只有没有key的时候，才能set成功，借此实现分布式锁。单机存在的问题是，如果应用申请锁成功，而此时master还未将锁资源同步给slave就下线了，这时候新选出的master没有锁资源，应用可以再次成功申请到锁，就会出现问题。
* 多机情况下，使用Redisson的红锁RedLock。
* 单机的实现，需要使用Lua脚本写，保证set和expire能够原子性的执行，利用可重入性，当某一线程获取到锁时，开启守护线程去检测并更新过期时间，防止锁过期提前释放。
* 多机实现，RedLock，对多个节点发送获取锁资源，超过一半的节点在有效时间内获取成功，才算获取锁成功，获取失败就在master删除锁资源。

#### 1.5、redis的数据类型

string、list、hash、set和zset，string字符串，用得最多，list类似于linkedList，hash类似于hashMap，set即集合，zset有序集合，基于跳跃表实现，索引个数，logN。

#### 1.6、redis集群

#### 1.7、redis脑裂问题

#### 1.8、redis字典结构

类似于java的hashmap，使用了数组+链表的形式，通过hash算法确定要将节点放到数组的哪个位置上，如果发生hash冲突，就用一条链表给存起来。如果哈希表的键值对数量超过负载因子时，就触发rehash，哈希表的负载因子=ht[0].used/ht[0].size，这点与Java hashMap有点不同，它是可以超过1的。redis哈希表的rehash，使用了ht[0]和ht[1]，根据ht[0]计算ht[1]大小，然后重新计算hash值，把ht[0]的数据放到ht[1]中，并且redis采用了一种渐进式hash的方式，因为很可能存了很多键值对，如果一次性hash，会造成服务一段时间内不能用，渐进式hash是当进行查询或者修改等操作时，再进行hash，会设置一个index，每次将ht[index]的所有键值对重新放入到ht[1]中，直到全部放完将index置为-1，表示rehash完成。就把rehash过程均摊到多次上。

#### 1.9、缓存穿透、缓存雪崩和缓存击穿，以及解决办法

首先注意缓存穿透和缓存击穿的区别。

* 缓存穿透，指请求了缓存和数据库中都没有的数据，这样请求落到了数据库，造成数据库压力大，解决办法，1、在缓存中将数据库没有的数据设置为null，避免直接查到数据库；2、布隆过滤器，先经过布隆过滤器判断是否是数据库中存在的数据；
* 缓存击穿，指请求了缓存中没有但数据库中有的数据，这种发生在并发比较高的场景，由于同时请求缓存，因为没有缓存，又同时请求数据库数据，造成数据库压力大。解决办法：1、互斥锁，避免大量请求同时落到数据库；2、设置热点数据永不过期。
* 缓存雪崩，指缓存大面积失效，造成请求都落到了数据库上，加大了数据库压力。解决办法：1、针对服务宕机的情况，增加服务节点，并将缓存均摊到多个节点上，避免一个节点失效造成缓存大面积不可用；2、针对同时失效问题，设置缓存失效时间不同，热点数据设置永不过期。

#### 1.10、缓存和数据库数据一致性

#### 1.11、redis的单线程模型

## 2、MySQL

#### 2.1、MVCC工作原理

#### 2.2、读写锁

#### 2.3、InnoDB和MyISAM

