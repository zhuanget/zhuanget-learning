## 报文结构

1.起始行：描述请求或响应的基本信息；

2.头部字段集合：使用key-value形式更详细地说明报文；

3.消息正文：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。

起始行和头部字段经常又合称为“请求头”或“响应头”，消息正文又称为“实体”。

HTTP协议规定报文必须有header，但可以没有body，而且在header之后必须要有一个“空行”，也就是“CRLF”。

![报文结构](D:\学习\记录笔记\zhuanget-learning\图片\62e061618977565c22c2cf09930e1d3c.png)

## 请求行

请求报文里的起始行，即请求行，它简要地描述了客户端想要如何操作服务器端的资源。

请求行由三部分构成：

1.请求方法：是一个动词，如GET/POST，表示对资源的操作；

2.请求目标：通常是一个URI，标记了请求方法要操作的资源；

3.版本号：表示报文使用的HTTP协议版本。

这三个部分通常使用空格来分隔，最后要用CRLF换行表示结束。

![请求行](D:\学习\记录笔记\zhuanget-learning\图片\请求行.png)

## 状态行

响应报文里的起始行，叫“状态行”，意思是服务器响应的状态。

状态行同样是由三部分构成：

1.版本号：表示报文使用的HTTP协议版本；

2.状态码：一个三位数，用代码的形式表示处理的结果；

3.原因：状态码的补充说明，是更详细的解释文字，帮助人理解原因。

![状态行](D:\学习\记录笔记\zhuanget-learning\图片\状态行.png)

## 头部字段

头部字段是key-value的形式，key和value之间用“:”分隔，最后用CRLF换行表示字段结束。

### 常用头字段

HTTP协议规定了非常多的头部字段，基本上可以分为四大类：

1.通用字段：在请求头和响应头里都可以出现；

2.请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附件条件；

3.响应字段：仅能出现在响应头里，补充说明响应报文的信息；

4.实体字段：它实际上属于通用字段，但专门描述body的额外信息。

#### Host

请求字段，HTTP/1.1规范里要求必须出现的字段。Host字段告诉服务器这个请求应该由哪个主机来处理，当一台计算机上托管了多个虚拟主机的时候，服务器端就需要用Host字段来选择。

#### User-Agent

请求字段，服务器可以依据它来返回最合适此浏览器显示的页面。

#### Date

通用字段，但通常出现在响应头里，表示HTTP报文创建的时间。

#### Server

响应字段，告诉客户端正在提供Web服务的软件名称和版本号。

#### Content-Length

表示报文里body的长度，也就是请求头或响应头空行后面数据的长度。服务器看到这个字段，就知道了后续有多少数据，可以直接接收。如果没有这个字段，那么body就是不定长的，需要使用chunked方式分段传输。

## 请求方法

八种方法：

1、GET：获取资源，读取或者下载数据；

2、HEAD：获取资源的元信息；

3、POST：向资源提交数据，相当于写入或上传数据；

4、PUT：类似POST；

5、DELETE：删除资源；

6、CONNECT：建立特殊的连接隧道；

7、OPTIONS：列出可对资源实行的方法；

8、TRACE：追踪请求-响应的传输路径。

**HEAD**方法与GET方法类似，也是请求从服务器获取资源，服务器的处理机制也是一样的，但服务器不会返回请求的实体数据，只会返回响应头。

## 安全与幂等

**安全：**在HTTP协议里，安全是指请求方法不会破坏服务器上的资源，即不会对服务器上的资源造成实质的修改。GET和HEAD方法是安全的，因为它们是只读操作。

**幂等：**意思是多次执行相同的操作，结果也都是相同的。

GET/HEAD/DELETE/PUT是幂等的，POST不是幂等的。

## 状态码

五类：

* 1XX：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；
* 2XX：成功，报文已经收到并被正确处理；
* 3XX：重定向，资源位置发送变动，需要客户端重新发送请求；
* 4XX：客户端错误，请求报文有误，服务器无法处理；
* 5XX：服务器错误，服务器在处理请求时内部发送了错误。

### 2xx

**200 OK**

**204 No Content**：含义与200基本相同，但响应头后没有body数据。

**206 Partial Content：**是HTTP分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现，状态码206通常还会伴随着头字段“Content-Range”，表示响应报文里body数据的具体范围，供客户端确认。

### 3xx

**301 Moved Permanently：**永久重定向，此次请求的资源已经不存在了，需要改用新的URI再次访问。

**302 Moved Temporarily：**临时重定向，意思是请求的资源还在，但需要暂时用另一个URI来访问。

301和302都会在响应头里使用字段Location指明后续要跳转的URI，最终的效果很相似，浏览器都会重定向到新的URI。

**304 Not Modified：**用于If-Modified-Since等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件”（即“缓存重定向”）。

### 4xx

**400 Bad Request：**通用的错误码，表示请求报文有错误，但具体是数据格式错误、缺少请求头还是URI超长没有明确说。

**403 Forbidden：**实际上不是客户端的请求出错，而是表示服务器禁止访问资源。

**404 Not Found：**

**405 Method Not Allowed：**不允许使用某些方法操作资源。

### 5xx

**500 Internal Server Error：**通用错误码。

**503 Service Unavailable：**表示服务器当前很忙，暂时无法响应服务。

# 实体数据

## 数据类型与编码

HTTP协议作为应用层协议，在数据到底之后，还需要告诉上层应用这是什么数据。针对该问题的解决方案是“多用途互联网邮件扩展”，简称MIME，HTTP取了其中的一部分，即“MIME type”。

MIME把数据分成了八大类，每个大类下再细分出多个子类，形式是“type/subtype”的字符串。

常见的几个类别：

1、text：即文本格式的可读数据，如text/html，text/plain，text/css。

2、image：即图像文件，有image/gif，image/jpeg，image/png。

3、audio/video：音频和视频数据，如audio/mpeg，video/mp4.

4、application：可能是文本也可能是二进制，必须由上层应用程序来解释，如application/json，application/javascript，application/pdf。

Encoding type：

1、gzip；2、deflate；3、br。

### 数据类型使用的头字段

**Accept**字段标记的是客户端可理解的MIME type，可以用“,”做分隔符列出多个类型。

服务器会在响应报文里用头字段**Content-Type**告诉实体数据的真实类型。

**Accept-Encoding**字段标记的是客户端支持的压缩格式，同样也可以用“,”列出多个。

服务器将实际使用的压缩格式放在响应头字段**Content-Encoding**里。

## HTTP传输大文件的方法

### 数据压缩

浏览器在发送请求时带上**Accept-Encoding**头字段，里面是浏览器支持的压缩格式列表，服务器从中选择一种压缩算法，放进**Content-Encoding**响应头里，再把原数据压缩后发给浏览器。

### 分块传输

在响应报文里用头字段**Transfer-Encoding: chunked**，意思是报文里的body部分不是一次性发过来的，而是分成了许多的块（chunk）逐个发送。

**Transfer-Encoding: chunked**和**Content-Length**这两个字段是互斥的，响应报文里这两个字段不能同时出现，一个响应报文的传输要么是长度已知，要么是长度未知（chunked）。

![chunk](D:\学习\记录笔记\zhuanget-learning\图片\chunk.png)

### 范围请求

服务器通过在响应头里使用**Accept-Ranges: bytes**告知客户端是支持范围请求的。请求头**Range**是HTTP范围请求的专用字段，格式是**bytes=x-y**，其中的x和y是以字节为单位的数据范围。

## HTTP的连接管理

### 短连接与长连接

什么是短连接和长连接？

HTTP协议底层的数据传输基于TCP/IP，每次发送请求前需要先与服务器建立连接，收到响应报文后会立即关闭连接。整个连接过程很短暂，不会与服务器保持长时间的连接状态，所以就被称为“短连接”。由于在TCP协议里，建立和关闭连接都是非常昂贵的操作，这种短连接方式会浪费数据传输时间，传输效率低下。

长连接通过保持连接状态，在首次建立连接之后就不再关闭连接，之后的数据传输都通过该TCP连接进行传输，减少后续传输建立和关闭连接的时间，提高传输效率。但是长连接也不能一直都不关闭，由于保持连接不关闭，需要服务器在内存中保存它的状态，这就占用率服务器的资源。如果有大量的空闲长连接只连不发，就会消耗服务器的资源。服务器和客户端都可以关闭掉长连接，客户端可以通过在请求头里加上**Connection: close**字段，告诉服务器关闭连接。服务器一般不会主动关闭连接，但可以使用一些策略，例如nginx的两种方式：keepalive_timeout，设置长连接的超时时间；keepalive_requests，设置在该连接上能够处理的最大请求数。

另外，客户端和服务器都可以在报文里附件通用头字段**Keep-Alive: timeout = value**来限定长连接的超时时间。

**队头阻塞**问题会导致性能下降，可以用并发连接和域名分片技术缓解。