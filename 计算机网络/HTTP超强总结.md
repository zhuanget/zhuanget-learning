## 报文结构

1.起始行：描述请求或响应的基本信息；

2.头部字段集合：使用key-value形式更详细地说明报文；

3.消息正文：实际传输的数据，它不一定是纯文本，可以是图片、视频等二进制数据。

起始行和头部字段经常又合称为“请求头”或“响应头”，消息正文又称为“实体”。

HTTP协议规定报文必须有header，但可以没有body，而且在header之后必须要有一个“空行”，也就是“CRLF”。

![报文结构](D:\学习\记录笔记\zhuanget-learning\图片\62e061618977565c22c2cf09930e1d3c.png)

## 请求行

请求报文里的起始行，即请求行，它简要地描述了客户端想要如何操作服务器端的资源。

请求行由三部分构成：

1.请求方法：是一个动词，如GET/POST，表示对资源的操作；

2.请求目标：通常是一个URI，标记了请求方法要操作的资源；

3.版本号：表示报文使用的HTTP协议版本。

这三个部分通常使用空格来分隔，最后要用CRLF换行表示结束。

![请求行](D:\学习\记录笔记\zhuanget-learning\图片\请求行.png)

## 状态行

响应报文里的起始行，叫“状态行”，意思是服务器响应的状态。

状态行同样是由三部分构成：

1.版本号：表示报文使用的HTTP协议版本；

2.状态码：一个三位数，用代码的形式表示处理的结果；

3.原因：状态码的补充说明，是更详细的解释文字，帮助人理解原因。

![状态行](D:\学习\记录笔记\zhuanget-learning\图片\状态行.png)

## 头部字段

头部字段是key-value的形式，key和value之间用“:”分隔，最后用CRLF换行表示字段结束。

### 常用头字段

HTTP协议规定了非常多的头部字段，基本上可以分为四大类：

1.通用字段：在请求头和响应头里都可以出现；

2.请求字段：仅能出现在请求头里，进一步说明请求信息或者额外的附件条件；

3.响应字段：仅能出现在响应头里，补充说明响应报文的信息；

4.实体字段：它实际上属于通用字段，但专门描述body的额外信息。

#### Host

请求字段，HTTP/1.1规范里要求必须出现的字段。Host字段告诉服务器这个请求应该由哪个主机来处理，当一台计算机上托管了多个虚拟主机的时候，服务器端就需要用Host字段来选择。

#### User-Agent

请求字段，服务器可以依据它来返回最合适此浏览器显示的页面。

#### Date

通用字段，但通常出现在响应头里，表示HTTP报文创建的时间。

#### Server

响应字段，告诉客户端正在提供Web服务的软件名称和版本号。

#### Content-Length

表示报文里body的长度，也就是请求头或响应头空行后面数据的长度。服务器看到这个字段，就知道了后续有多少数据，可以直接接收。如果没有这个字段，那么body就是不定长的，需要使用chunked方式分段传输。

## 请求方法

八种方法：

1、GET：获取资源，读取或者下载数据；

2、HEAD：获取资源的元信息；

3、POST：向资源提交数据，相当于写入或上传数据；

4、PUT：类似POST；

5、DELETE：删除资源；

6、CONNECT：建立特殊的连接隧道；

7、OPTIONS：列出可对资源实行的方法；

8、TRACE：追踪请求-响应的传输路径。

**HEAD**方法与GET方法类似，也是请求从服务器获取资源，服务器的处理机制也是一样的，但服务器不会返回请求的实体数据，只会返回响应头。

## 安全与幂等

**安全：**在HTTP协议里，安全是指请求方法不会破坏服务器上的资源，即不会对服务器上的资源造成实质的修改。GET和HEAD方法是安全的，因为它们是只读操作。

**幂等：**意思是多次执行相同的操作，结果也都是相同的。

GET/HEAD/DELETE/PUT是幂等的，POST不是幂等的。

## 状态码

五类：

* 1XX：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；
* 2XX：成功，报文已经收到并被正确处理；
* 3XX：重定向，资源位置发送变动，需要客户端重新发送请求；
* 4XX：客户端错误，请求报文有误，服务器无法处理；
* 5XX：服务器错误，服务器在处理请求时内部发送了错误。

### 2xx

**200 OK**

**204 No Content**：含义与200基本相同，但响应头后没有body数据。

**206 Partial Content：**是HTTP分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现，状态码206通常还会伴随着头字段“Content-Range”，表示响应报文里body数据的具体范围，供客户端确认。

### 3xx

**301 Moved Permanently：**永久重定向，此次请求的资源已经不存在了，需要改用新的URI再次访问。

**302 Moved Temporarily：**临时重定向，意思是请求的资源还在，但需要暂时用另一个URI来访问。

301和302都会在响应头里使用字段Location指明后续要跳转的URI，最终的效果很相似，浏览器都会重定向到新的URI。

**304 Not Modified：**用于If-Modified-Since等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件”（即“缓存重定向”）。

### 4xx

**400 Bad Request：**通用的错误码，表示请求报文有错误，但具体是数据格式错误、缺少请求头还是URI超长没有明确说。

**403 Forbidden：**实际上不是客户端的请求出错，而是表示服务器禁止访问资源。

**404 Not Found：**

**405 Method Not Allowed：**不允许使用某些方法操作资源。

### 5xx

**500 Internal Server Error：**通用错误码。

**503 Service Unavailable：**表示服务器当前很忙，暂时无法响应服务。

# 实体数据

## 数据类型与编码

HTTP协议作为应用层协议，在数据到底之后，还需要告诉上层应用这是什么数据。针对该问题的解决方案是“多用途互联网邮件扩展”，简称MIME，HTTP取了其中的一部分，即“MIME type”。

MIME把数据分成了八大类，每个大类下再细分出多个子类，形式是“type/subtype”的字符串。

常见的几个类别：

1、text：即文本格式的可读数据，如text/html，text/plain，text/css。

2、image：即图像文件，有image/gif，image/jpeg，image/png。

3、audio/video：音频和视频数据，如audio/mpeg，video/mp4.

4、application：可能是文本也可能是二进制，必须由上层应用程序来解释，如application/json，application/javascript，application/pdf。

Encoding type：

1、gzip；2、deflate；3、br。

### 数据类型使用的头字段

**Accept**字段标记的是客户端可理解的MIME type，可以用“,”做分隔符列出多个类型。

服务器会在响应报文里用头字段**Content-Type**告诉实体数据的真实类型。

**Accept-Encoding**字段标记的是客户端支持的压缩格式，同样也可以用“,”列出多个。

服务器将实际使用的压缩格式放在响应头字段**Content-Encoding**里。

## HTTP传输大文件的方法

### 数据压缩

浏览器在发送请求时带上**Accept-Encoding**头字段，里面是浏览器支持的压缩格式列表，服务器从中选择一种压缩算法，放进**Content-Encoding**响应头里，再把原数据压缩后发给浏览器。

### 分块传输

在响应报文里用头字段**Transfer-Encoding: chunked**，意思是报文里的body部分不是一次性发过来的，而是分成了许多的块（chunk）逐个发送。

**Transfer-Encoding: chunked**和**Content-Length**这两个字段是互斥的，响应报文里这两个字段不能同时出现，一个响应报文的传输要么是长度已知，要么是长度未知（chunked）。

![chunk](D:\学习\记录笔记\zhuanget-learning\图片\chunk.png)

### 范围请求

服务器通过在响应头里使用**Accept-Ranges: bytes**告知客户端是支持范围请求的。请求头**Range**是HTTP范围请求的专用字段，格式是**bytes=x-y**，其中的x和y是以字节为单位的数据范围。

## HTTP的连接管理

### 短连接与长连接

什么是短连接和长连接？

HTTP协议底层的数据传输基于TCP/IP，每次发送请求前需要先与服务器建立连接，收到响应报文后会立即关闭连接。整个连接过程很短暂，不会与服务器保持长时间的连接状态，所以就被称为“短连接”。由于在TCP协议里，建立和关闭连接都是非常昂贵的操作，这种短连接方式会浪费数据传输时间，传输效率低下。

长连接通过保持连接状态，在首次建立连接之后就不再关闭连接，之后的数据传输都通过该TCP连接进行传输，减少后续传输建立和关闭连接的时间，提高传输效率。但是长连接也不能一直都不关闭，由于保持连接不关闭，需要服务器在内存中保存它的状态，这就占用率服务器的资源。如果有大量的空闲长连接只连不发，就会消耗服务器的资源。服务器和客户端都可以关闭掉长连接，客户端可以通过在请求头里加上**Connection: close**字段，告诉服务器关闭连接。服务器一般不会主动关闭连接，但可以使用一些策略，例如nginx的两种方式：keepalive_timeout，设置长连接的超时时间；keepalive_requests，设置在该连接上能够处理的最大请求数。

另外，客户端和服务器都可以在报文里附件通用头字段**Keep-Alive: timeout = value**来限定长连接的超时时间。

**队头阻塞**问题会导致性能下降，可以用并发连接和域名分片技术缓解。

## Cookie机制

响应头字段**Set-Cookie**和请求头字段**Cookie**。

### 什么是Cookie?

由于HTTP是无状态的，当用户

### Cookie的工作过程？

需要用到两个字段：响应头字段**Set-Cookie**和请求头字段**Cookie**。

1、当用户通过浏览器第一次访问服务器时，服务器肯定不知道他的身份，就创建了一个独特的身份标识数据，格式是**key=value**，然后放进Set-Cookie字段里，随着响应报文一同发给浏览器。

2、浏览器收到响应报文，看到里面有Set-Cookie，就保存起来，下次再请求时就自动把这个值放进Cookie字段里发给服务器。

3、第二次请求里面有了Cookie字段，服务器就知道这个用户不是新人，就从Cookie中取出值，识别出用户的身份，然后提供个性化的服务。

### Cookie的属性

#### Cookie的生命周期

**Expires、Max-Age**：可以通过这两个属性来设置Cookie的生存周期，可以同时出现，可以一致也可以不一致，但浏览器会优先采用Max-Age计算失效期；

#### Cookie的作用域

**Domain、Path：**指定Cookie所属的域名和路径，设置Cookie的作用域，让浏览器仅发送给特定的服务器和URI，避免被其他网站盗用；

#### Cookie的安全性

**HttpOnly：**设置此Cookie只能通过浏览器HTTP协议传输，禁止其他方式访问，防止跨站脚本（XSS）攻击。

**SameSite：**防范“跨站请求伪造”（XSRF）攻击，SameSite=Strict严格限定Cookie不能随着跳转连接跨站发送；SameSite=Lax，允许GET/HEAD等安全方法，但禁止POST跨站发送。

### Cookie的应用

身份识别、广告跟踪

## HTTP的缓存控制

## HTTP代理

### 代理服务

代理服务是指服务本身不生产内容，而是处于中间位置转发上下游的请求和响应，具有双重身份。

### 代理的作用

* 负载均衡：由于客户端看到的只是代理服务器，于是代理服务器就可以掌握请求分发的“大权”，决定由后面的哪台服务器来响应请求；
* 健康检查：使用“心跳”等机制监控后端服务器，发现有故障就及时“踢出”集群，保证服务高可用；
* 安全防护：保护被代理的后端服务器，限制IP地址或流量，抵御网络攻击和过载；
* 加密卸载：对外网使用SSL/TLS加密通信认证，而在安全的内网不加密，消除加解密成本；
* 数据过滤：拦截上下行的数据，任意指定策略修改请求或者响应；
* 内容缓存：暂存、复用服务器响应。

### 代理相关头字段

**Via：**通用字段，每当报文经过一个代理节点，代理服务器就会把自身的信息追加到字段的末尾。

**X-Forwarded-For、X-Real-IP：**X-Forwarded-For每经过一个代理节点就会在字段里追加请求方的IP地址；X-Real-IP记录客户端IP地址。

# HTTPS

### 通信安全需要具备的四个特性

* 机密性：数据保密，只能由可信的人访问，对其他人是不可见的“秘密”；
* 完整性：指数据在传输过程中没有被篡改；
* 身份认证：指确认对方的真实身份，保证消息只能发送给可信的人；
* 不可否认：意思是不能否认已经发生过的行为。

机密性由对称加密AES保证，完整性由SHA384摘要算法保证，身份认证和不可否认由RSA非对称加密保证。

### HTTPS与HTTP的不同

HTTPS把HTTP下层的传输协议由TCP/IP换成了SSL/TLS，让HTTP运行在了安全的SSL/TLS协议上，收发报文不再使用Socket API，而是调用专门的安全接口。默认端口号为443。

### SSL/TLS

SSL即安全套接层，在OSI模型中处于第5层（会话层）。

浏览器和服务器在使用TLS建立连接时需要选择一组恰当的加密算法来实现安全通信，这些算法的组合被称为“密码套件”。

#### 密码套件命名规范

基本形式是“密钥交换算法+签名算法+对称加密算法+摘要算法”，如 ECDHE-RSA-AES256-GCM-SHA384 ，意思是握手时使用ECDHE算法进行密钥交换，用RSA签名和身份认证，握手后的通信使用AES对称算法，密钥长度256位，分组模式是GCM，摘要算法SHA384用于消息认证和产生随机数。

#### OpenSSL

著名的开源密码学工具包，是SSL/TLS的具体实现。

## 对称加密与非对称加密

### 一些概念

加密、密钥、明文、密文、解密、加密算法

HTTP协议是明文传输的，通过加密算法对明文进行加密，生成密文后再进行传输，接收方再通过密钥对密文进行解密，还原明文。

### 对称加密

对称加密，加密和解密时使用的密钥都是同一个。只要保证了密钥的安全，那整个通信过程就可以说具有了机密性。

#### 常用对称加密算法

AES、ChaCha20。

AES128：使用AES对称加密算法，密钥长度128

笔记：密钥与加密算法的理解：可以把加密算法看成一个函数，用这个函数就可以把明文转换成密文，而密钥可以简单理解为这个转换函数的一个因子，虽然函数形式是相同的，但是因子不同，计算的结果就不一样，只有持有相关（可能是相同的，也可能是相反的）才能从结果反推出原来的数据。

#### 加密分组模式

分组模式，让算法用固定长度的密钥加密任意长度的明文。

最新的分组模式被称为AEAD，在加密的同时增加了认证的功能，常用的是GCM、CCM和Poly1305.

TLS密码套件中定义的对称加密算法：AES128-GCM，密钥长度为128位的AES算法，使用的分组模式是GCM。

### 非对称加密

密钥交换：如何把密钥安全地传递给对方。

两个不同的密钥，公钥和私钥，公钥可以公开给任何人使用，而私钥必须严格保密。

单向性：公钥加密后只能用私钥解密，私钥加密后只能用公钥解密。

#### 非对称加密如何解决密钥交换问题

网站秘密保管私钥，在网上任意分发公钥，登录网站只要用公钥加密就行，密文只能由私钥持有者才能解密。而黑客因为没有私钥，所以就无法破解密文。

笔记：你登录网站时，输入账号密码，经过网站分发的公钥加密后成为了密文，密文如果在传输的过程中被黑客截取，然而黑客并没有私钥，即使他可能拥有公钥，他也破解不出，因此是安全的。

#### 常用非对称加密算法

RSA、ECC、DSA、DH。

* RSA：基于整数分解，使用两个超大素数的乘积作为生成密钥的材料；
* ECC：基于椭圆曲线离散对数，使用特定的曲线方程和基点生成公钥和私钥，子算法ECDHE用于密钥交换，ECDSA用于数字签名。

### 混合加密

用非对称算法解决密钥交换问题，然后用随机数产生对称算法使用的会话密钥，再用公钥加密。

## 数字签名与证书

### 摘要算法

实现完整性的手段，也就是常说的散列函数、哈希函数。

可以把摘要算法近似地理解成一种特殊的压缩算法，它能够把任意长度的数据“压缩”成固定长度、而且独一无二的“摘要”字符串，就好像是给这段数据生成了一个数字“指纹”。

#### SHA-2

SHA-2是一系列摘要算法的统称，总共有6种，常用的有SHA224、SHA256、SHA384

#### 完整性

摘要算法保证了数字摘要和原文是完全等价的，只要在原文后附上它的摘要，就能够保证数据的完整性。

验证过程：网站收到消息，根据消息以及相应的摘要算法，计算消息的摘要，然后与接收到的摘要进行比对，如果一致，说明消息是完整可信的，没有被修改。

不过摘要算法不具有机密性，如果明文传输，那么黑客可以修改消息后把摘要也一起改了，网站还是鉴别不出完整性。所以，真正的完整性必须要建立在机密性之上，在混合加密系统里用会话密钥加密消息和摘要，这样黑客无法得知明文，也就没有办法动手脚了。

### 数字签名

使用私钥再加上摘要算法，就能够实现数字签名，同时实现身份认证和不可否认。

数字签名的原理，私钥加密、公钥解密。

#### 数字证书和CA

